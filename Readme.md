# Lab-killer

Веб-приложение для лабораторных вычислений.
Основная часть - это язык программирования, похожий на матлаб, но с физтеховской спецификой.
Документация по языку представленна [здесь](https://github.com/timattt/TypeThree/blob/master/manual.pdf). Больше информации по легаси решению можно посмотреть [тут](https://github.com/timattt/Laboratory-calculations-optimizator).

# Архитектура

![image](https://github.com/timattt/TypeThree/assets/25401699/e0ee4363-ed55-4f46-b2ba-ab34cd8db1dd)

## Сущности

* **WebClient** - приложение на ReactJS. Пользователь пишет программу, потом она улетает на сервер, там воркеры ее выполняют и результат кладут в БД. А клиент каждые несколько секунд пингует **ResultsProvider**, и когда воркеры закончат он получит результат выполнения своего кода. Выглядеть в браузере это будет примерно так:
<img width="493" alt="image" src="https://github.com/timattt/TypeThree/assets/25401699/7d43d245-ab3e-4978-80a1-c1c6155e22d4">

* **Gateway** - сервис, который занимается перенаправлением трафика. Используем Spring Cloud Gateway. Через него внешний мир получает доступ к нашей инфраструктуре.
* **AuthService** - сервис, который занимается безопасностью пользователей. В данном проекте целесообразно использовать JWT. Пользователь через **WebClient** будет регистрироваться используя сторонние сервисы вроде яндекса или вк, а потом уже ему на основе сторонних токенов будет выдаваться наш локальный.
* **Interpreter** - интерпретатор осуществляет получение кода от клиента - создаем таску и отправляет ее в очередь.
* **InterpreterWorker** - краеугольный камень всей системы. Именно этот сервис обрабатывает языковые запросы и выполняет код.
* **TasksQueue** - кафка-очередь, которая хранит задачи. Куски кода, которые надо выполнить. Каждую таску должен получить ровно один воркер.
* **ResultsDB** - postgres база данных, в которую воркеры кладут результаты выполнения своих тасок.
* **ResultsProvider** - сервис, к которому есть доступ из клиента - он позволяет проверять - выполнена ли задача или нет. А также получать всю информацию о ней.
* **Utility** - группа сервисов для стандартных задач вроде хранения конфигурации и обнаружения. Реализовываются из коробки с помощью Spring Cloud. Использую яндекс облако, необходимость в них потенциально отпадает, так как там есть все свое.
* **Kafka broker** - брокер для очередей.

## Базовые сценарии работы

### Авторизация

1. Пользователь через **WebClient** отправляет креды в **Gateway**.
2. **Gateway** перенаправляет крелы в **AuthService**.
3. **AuthService** выдает токен и через **Gateway** пересылает его пользователю.

### Интерпретация

1. Пользователь через **WebClient** отправляет код в **Interpeter**.
2. **Interpeter** создает сообщение-задачу и кладет ее в **TasksQueue**.
3. Один из инстансов **InterpreterWorker** получает задачу из очереди.
4. **InterpreterWorker** интерпретирует задачу - получает какие-то числа, коды ошибок и т.д.
5. **InterpreterWorker** кладет результат свое работы в **ResultsDB**.

### Получение результатов

1. После того, как пользователь отправил код на бекэнд через **WebClient**, запускается таймер, который каждую секунд пингует **ResultsProvider**.
2. Запрос проходит через **Gateway** до **ResultsProvider**. Более того, обязательно проверяется авторизация пользователя и наличие прав на результат соответствующей задачи. Потому что доступ к данным должен быть только у того, кто их создал.
